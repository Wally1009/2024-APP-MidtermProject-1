"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hidden = void 0;
const react_1 = __importDefault(require("react"));
const react_2 = require("@gluestack-style/react");
const react_3 = require("@gluestack-style/react");
const react_native_1 = require("react-native");
const Hidden = ({ children, from, till, only, colorMode: colorModeforHide, platform: platformforHide, }) => {
    const { config: { tokens: { breakpoints }, }, } = (0, react_3.useStyled)();
    const breakpointShowArray = Object.keys(breakpoints).map((key) => ({
        [key]: true,
    }));
    const colorMode = (0, react_2.useColorMode)();
    let showFrom = true;
    let showTill = true;
    let showOnly = true;
    let showColorMode = true;
    let showPlatform = true;
    // from case
    let breakPointFrom = { base: true };
    if (from) {
        let flag = 0;
        breakPointFrom = Object.assign({}, breakpoints);
        for (const bpvalue of breakpointShowArray) {
            for (const key in bpvalue) {
                breakPointFrom[key] = true;
                if (flag === 1) {
                    breakPointFrom[key] = false;
                }
                if (key === from) {
                    flag = 1;
                    breakPointFrom[key] = false;
                }
            }
        }
    }
    showFrom = (0, react_2.useBreakpointValue)(breakPointFrom);
    // till case
    let breakPointTill = { base: true };
    if (till) {
        let flag = 0;
        breakPointTill = Object.assign({}, breakpoints);
        for (const bpvalue of breakpointShowArray) {
            for (const key in bpvalue) {
                breakPointTill[key] = false;
                if (flag === 1) {
                    breakPointTill[key] = true;
                }
                if (key === till) {
                    flag = 1;
                    breakPointTill[key] = true;
                }
            }
        }
    }
    showTill = (0, react_2.useBreakpointValue)(breakPointTill);
    // only case
    let breakPointOnly = { base: true };
    if (only) {
        showOnly = false;
        breakPointOnly = Object.assign({}, breakpoints);
        for (const key in breakPointOnly) {
            breakPointOnly[key] = true;
        }
        if (typeof only === 'string')
            breakPointOnly[only] = false;
        else {
            for (const bpvalue of only)
                breakPointOnly[bpvalue] = false;
        }
    }
    showOnly = (0, react_2.useBreakpointValue)(breakPointOnly);
    // platform case
    if (platformforHide) {
        showPlatform = false;
        if (react_native_1.Platform.OS !== platformforHide)
            showPlatform = true;
    }
    // colorMode case
    if (colorModeforHide) {
        showColorMode = false;
        if (colorModeforHide !== colorMode) {
            showColorMode = true;
        }
    }
    return showFrom &&
        showTill &&
        showOnly &&
        showColorMode &&
        showPlatform &&
        children ? (react_1.default.createElement(react_1.default.Fragment, null, children)) : (react_1.default.createElement(react_1.default.Fragment, null));
};
exports.Hidden = Hidden;

"use strict";
// @ts-nocheck
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitObject = exports.getFlattendMultiAliasesProps = exports.transformTheme = exports.deepMerge = exports.addDollarSignsToProps = exports.getColor = exports.getTransparentColor = exports.transparentize = exports.convertToSXForStateColorModeMediaQuery = exports.renamePseudoClasses = exports.platformSpecificSpaceUnits = exports.convertRemToAbsolute = exports.convertAbsoluteToPx = exports.convertAbsoluteToRem = exports.BASE_FONT_SIZE = exports.renamePseudoMap = exports.propertyTokenMap = exports.CSSPropertiesMap = void 0;
const react_native_1 = require("react-native");
const lodash_get_1 = __importDefault(require("lodash.get"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const tinycolor2_1 = __importDefault(require("tinycolor2"));
__exportStar(require("./stablehash"), exports);
__exportStar(require("./modifyConfig"), exports);
const dontResolveFromToken = ['top', 'left', 'right', 'bottom'];
exports.CSSPropertiesMap = {
    alignContent: 'stretch',
    alignItems: 'stretch',
    alignSelf: 'auto',
    aspectRatio: 'auto',
    borderBottomWidth: '0',
    borderLeftWidth: '0',
    borderRightWidth: '0',
    borderTopWidth: '0',
    borderEndWidth: '0',
    borderStartWidth: '0',
    borderWidth: '0',
    bottom: 'auto',
    direction: 'ltr',
    display: 'flex',
    // end: 'auto',
    // start: 'auto',
    flex: 'none',
    flexDirection: 'column',
    flexBasis: 'auto',
    flexGrow: '0',
    flexShrink: '1',
    flexWrap: 'nowrap',
    gap: 'normal',
    rowGap: 'normal',
    columnGap: 'normal',
    height: 'auto',
    justifyContent: 'flex-start',
    left: 'auto',
    margin: '0',
    marginBottom: '0',
    marginHorizontal: '0',
    marginLeft: '0',
    marginRight: '0',
    marginTop: '0',
    marginVertical: '0',
    marginEnd: '0',
    marginStart: '0',
    maxHeight: 'none',
    maxWidth: 'none',
    minHeight: 'auto',
    minWidth: 'auto',
    padding: '0',
    paddingBottom: '0',
    paddingHorizontal: '0',
    paddingLeft: '0',
    paddingRight: '0',
    paddingTop: '0',
    paddingVertical: '0',
    paddingEnd: '0',
    paddingStart: '0',
    position: 'relative',
    right: 'auto',
    top: 'auto',
    width: 'auto',
    zIndex: 'auto',
    shadowColor: 'transparent',
    shadowOffset: '0px 0px',
    shadowOpacity: '0',
    shadowRadius: '0',
    transform: 'none',
    transformOrigin: 'initial',
    backfaceVisibility: 'visible',
    backgroundColor: 'transparent',
    borderBottomLeftRadius: '0',
    borderBottomRightRadius: '0',
    borderColor: 'initial',
    borderRadius: '0',
    borderTopLeftRadius: '0',
    borderTopRightRadius: '0',
    opacity: '1',
    overflow: 'visible',
    overflowX: 'visible',
    overflowY: 'visible',
    borderBottomColor: 'initial',
    borderLeftColor: 'initial',
    borderRightColor: 'initial',
    borderStyle: 'none',
    borderTopColor: 'initial',
    elevation: '0',
    color: 'initial',
    fontFamily: 'system-ui',
    fontSize: 'initial',
    fontStyle: 'normal',
    fontVariant: 'normal',
    textTransform: 'none',
    fontWeight: 'normal',
    lineHeight: 'initial',
    textAlign: 'auto',
    textDecorationLine: 'none',
    textShadowColor: 'transparent',
    textShadowOffset: '0px 0px',
    textShadowRadius: '0',
    textAlignVertical: 'auto',
    letterSpacing: 'normal',
    textDecorationColor: 'initial',
    textDecorationStyle: 'solid',
    borderBottomEndRadius: '0',
    borderBottomStartRadius: '0',
    borderEndColor: 'initial',
    borderStartColor: 'initial',
    borderTopEndRadius: '0',
    borderTopStartRadius: '0',
};
const borderStyles = 'borderStyles';
const borderWidths = 'borderWidths';
const colors = 'colors';
const mediaQueries = 'mediaQueries';
const opacity = 'opacity';
const fonts = 'fonts';
const fontSizes = 'fontSizes';
const fontWeights = 'fontWeights';
const letterSpacings = 'letterSpacings';
const lineHeights = 'lineHeights';
const radii = 'radii';
const shadows = 'shadows';
const space = 'space';
const transitions = 'transitions';
const zIndices = 'zIndices';
exports.propertyTokenMap = {
    gap: space,
    gridGap: space,
    columnGap: space,
    gridColumnGap: space,
    rowGap: space,
    gridRowGap: space,
    inset: space,
    insetBlock: space,
    insetBlockEnd: space,
    insetBlockStart: space,
    insetInline: space,
    insetInlineEnd: space,
    insetInlineStart: space,
    margin: space,
    marginTop: space,
    marginRight: space,
    marginBottom: space,
    marginLeft: space,
    marginBlock: space,
    marginBlockEnd: space,
    marginBlockStart: space,
    marginInline: space,
    marginInlineEnd: space,
    marginInlineStart: space,
    marginHorizontal: space,
    marginVertical: space,
    padding: space,
    paddingTop: space,
    paddingRight: space,
    paddingBottom: space,
    paddingLeft: space,
    paddingBlock: space,
    paddingBlockEnd: space,
    paddingBlockStart: space,
    paddingInline: space,
    paddingInlineEnd: space,
    paddingInlineStart: space,
    paddingHorizontal: space,
    paddingVertical: space,
    paddingStart: space,
    paddingEnd: space,
    top: space,
    right: space,
    bottom: space,
    left: space,
    scrollMargin: space,
    scrollMarginTop: space,
    scrollMarginRight: space,
    scrollMarginBottom: space,
    scrollMarginLeft: space,
    scrollMarginX: space,
    scrollMarginY: space,
    scrollMarginBlock: space,
    scrollMarginBlockEnd: space,
    scrollMarginBlockStart: space,
    scrollMarginInline: space,
    scrollMarginInlineEnd: space,
    scrollMarginInlineStart: space,
    scrollPadding: space,
    scrollPaddingTop: space,
    scrollPaddingRight: space,
    scrollPaddingBottom: space,
    scrollPaddingLeft: space,
    scrollPaddingX: space,
    scrollPaddingY: space,
    scrollPaddingBlock: space,
    scrollPaddingBlockEnd: space,
    scrollPaddingBlockStart: space,
    scrollPaddingInline: space,
    scrollPaddingInlineEnd: space,
    scrollPaddingInlineStart: space,
    // shadowOffset: space,
    shadowRadius: space,
    elevation: space,
    fontSize: fontSizes,
    background: colors,
    backgroundColor: colors,
    backgroundImage: colors,
    borderImage: colors,
    border: colors,
    borderBlock: colors,
    borderBlockEnd: colors,
    borderBlockStart: colors,
    borderBottom: colors,
    borderBottomColor: colors,
    borderColor: colors,
    borderInline: colors,
    borderInlineEnd: colors,
    borderInlineStart: colors,
    borderLeft: colors,
    borderLeftColor: colors,
    borderRight: colors,
    borderRightColor: colors,
    borderTop: colors,
    borderTopColor: colors,
    caretColor: colors,
    color: colors,
    columnRuleColor: colors,
    fill: colors,
    outline: colors,
    outlineColor: colors,
    outlineWidth: space,
    stroke: colors,
    textDecorationColor: colors,
    shadowColor: colors,
    shadowOpacity: opacity,
    shadow: shadows,
    // Media Query
    condition: mediaQueries,
    fontFamily: fonts,
    fontWeight: fontWeights,
    lineHeight: lineHeights,
    letterSpacing: letterSpacings,
    blockSize: space,
    minBlockSize: space,
    maxBlockSize: space,
    inlineSize: space,
    minInlineSize: space,
    maxInlineSize: space,
    width: space,
    minWidth: space,
    maxWidth: space,
    height: space,
    minHeight: space,
    maxHeight: space,
    flexBasis: space,
    gridTemplateColumns: space,
    gridTemplateRows: space,
    borderWidth: borderWidths,
    borderTopWidth: borderWidths,
    borderRightWidth: borderWidths,
    borderBottomWidth: borderWidths,
    borderLeftWidth: borderWidths,
    borderStyle: borderStyles,
    borderTopStyle: borderStyles,
    borderRightStyle: borderStyles,
    borderBottomStyle: borderStyles,
    borderLeftStyle: borderStyles,
    borderRadius: radii,
    borderTopLeftRadius: radii,
    borderTopRightRadius: radii,
    borderBottomRightRadius: radii,
    borderBottomLeftRadius: radii,
    boxShadow: colors,
    textShadow: shadows,
    transition: transitions,
    zIndex: zIndices,
};
exports.renamePseudoMap = {
    _indeterminate: ':indeterminate',
    _checked: ':checked',
    _readOnly: ':readOnly',
    _required: ':required',
    _invalid: ':invalid',
    _focus: ':focus',
    _focusVisible: ':focusVisible',
    _hover: ':hover',
    _pressed: ':active',
    _active: ':active',
    _disabled: ':disabled',
    // _web: '_web',
    // _android: '_android',
    // _ios: '_ios',
    // _light: '_light',
    // _dark: '_dark',
};
exports.BASE_FONT_SIZE = 16;
const convertAbsoluteToRem = (px) => {
    return `${px / exports.BASE_FONT_SIZE}rem`;
};
exports.convertAbsoluteToRem = convertAbsoluteToRem;
const convertAbsoluteToPx = (px) => {
    return `${px}px`;
};
exports.convertAbsoluteToPx = convertAbsoluteToPx;
const convertRemToAbsolute = (rem) => {
    return rem * exports.BASE_FONT_SIZE;
};
exports.convertRemToAbsolute = convertRemToAbsolute;
const platformSpecificSpaceUnits = (theme) => {
    const scales = ['space', 'sizes', 'fontSizes'];
    const newTheme = (0, lodash_clonedeep_1.default)(theme);
    const isWeb = react_native_1.Platform.OS === 'web';
    scales.forEach((key) => {
        const scale = (0, lodash_get_1.default)(theme.tokens, key, {});
        const newScale = Object.assign({}, scale);
        for (const scaleKey in scale) {
            const val = scale[scaleKey];
            if (typeof val !== 'object') {
                const isAbsolute = typeof val === 'number';
                const isPx = !isAbsolute && val.endsWith('px');
                const isRem = !isAbsolute && val.endsWith('rem');
                const isEm = !isAbsolute && val.endsWith('em');
                // If platform is web, we need to convert absolute unit to rem. e.g. 16 to 1rem
                if (isWeb) {
                    if (isAbsolute) {
                        newScale[scaleKey] = (0, exports.convertAbsoluteToRem)(val);
                    }
                }
                // If platform is not web, we need to convert px unit to absolute and rem unit to absolute. e.g. 16px to 16. 1rem to 16.
                else {
                    if (isRem || isEm) {
                        newScale[scaleKey] = (0, exports.convertRemToAbsolute)(parseFloat(val));
                    }
                    else if (isPx) {
                        newScale[scaleKey] = parseFloat(val);
                    }
                }
            }
        }
        newTheme.tokens[key] = newScale;
    });
    return newTheme;
};
exports.platformSpecificSpaceUnits = platformSpecificSpaceUnits;
function renamePseudoClasses(obj) {
    for (const key in obj) {
        if (exports.renamePseudoMap[key]) {
            obj[exports.renamePseudoMap[key]] = obj[key];
            delete obj[key];
            renamePseudoClasses(obj[key]);
        }
        else if (typeof obj[key] === 'object') {
            renamePseudoClasses(obj[key]);
        }
    }
    return obj;
}
exports.renamePseudoClasses = renamePseudoClasses;
function convertResponsiveToPseudoClasses(obj, config) {
    var _a;
    const newObj = {};
    for (const key in obj) {
        const propName = key;
        const propValue = obj[key];
        if (checkIfPropIsStyle(key, config)) {
            if (Array.isArray(propValue)) {
                const breakPoints = (_a = config === null || config === void 0 ? void 0 : config.tokens) === null || _a === void 0 ? void 0 : _a.breakpoints;
                const breakPointsKeys = Object.keys(breakPoints);
                propValue.forEach((value, index) => {
                    //TODO: fix this ts-ignore
                    if (newObj[`@${breakPointsKeys[index]}`]) {
                        newObj[`@${breakPointsKeys[index]}`][propName] = value;
                    }
                    else {
                        newObj[`@${breakPointsKeys[index]}`] = { [propName]: value };
                    }
                });
            }
            else if (typeof propValue === 'object' && !propName.startsWith('_')) {
                // const breakPoints = config.tokens.breakpoints;
                // const breakPointsKeys = Object.keys(breakPoints);
                Object.keys(propValue).forEach((value) => {
                    //TODO: fix this ts-ignore
                    if (newObj[`@${value}`]) {
                        newObj[`@${value}`][propName] = propValue[value];
                    }
                    else {
                        newObj[`@${value}`] = { [propName]: propValue[value] };
                    }
                });
            }
            else if (typeof propValue === 'object') {
                //TODO: fix this ts-ignore
                newObj[key] = convertResponsiveToPseudoClasses(propValue, config);
            }
            else {
                //TODO: fix this ts-ignore
                newObj[key] = propValue;
            }
        }
        else {
            newObj[key] = propValue;
            // newObj.props = { ...newObj.props, [key]: propValue };
            // console.log('------', { ...newObj.props, [key]: propValue });
        }
    }
    // console.log('newObj', newObj);
    return newObj;
}
function convertToSXForStateColorModeMediaQuery(inputObj, _config) {
    const newObj = {
    // ...obj,
    };
    const obj = convertResponsiveToPseudoClasses(inputObj, _config);
    const newPseudoClass = renamePseudoClasses(obj);
    for (const key in newPseudoClass) {
        const propName = key;
        //TODO: fix this ts-ignore
        const propValue = obj[key];
        if (propName.startsWith('_') ||
            propName.startsWith(':') ||
            propName.startsWith('@')) {
            newObj[propName] = convertToSXForStateColorModeMediaQuery(propValue, _config);
        }
        else {
            newObj[propName] = propValue;
        }
    }
    return newObj;
}
exports.convertToSXForStateColorModeMediaQuery = convertToSXForStateColorModeMediaQuery;
function addDollarSign(propertyName, propValue, config) {
    var _a, _b;
    if (exports.CSSPropertiesMap.hasOwnProperty(propertyName)) {
        const tokenAvailable = (config === null || config === void 0 ? void 0 : config.tokens[exports.propertyTokenMap[propertyName]])
            ? config === null || config === void 0 ? void 0 : config.tokens[exports.propertyTokenMap[propertyName]][propValue]
            : undefined;
        if (tokenAvailable === undefined) {
            if ((typeof propValue === 'number' && !isNaN(propValue)) ||
                (typeof propValue === 'string' && !isNaN(Number(propValue)))) {
                if (Number(propValue) < 0 &&
                    ((_b = (_a = config === null || config === void 0 ? void 0 : config.tokens) === null || _a === void 0 ? void 0 : _a[exports.propertyTokenMap === null || exports.propertyTokenMap === void 0 ? void 0 : exports.propertyTokenMap[propertyName]]) === null || _b === void 0 ? void 0 : _b[String(propValue).slice(1)])) {
                    return dontResolveFromToken.includes(propertyName)
                        ? Number(propValue)
                        : `-$${String(propValue).slice(1)}`;
                }
                return Number(propValue);
            }
            if (typeof propValue === 'string' && propValue.includes(':alpha.')) {
                return `$${propValue}`;
            }
            return propValue;
        }
        else {
            return `$${propValue}`;
        }
    }
    else {
        return propValue;
    }
}
const transparentize = (color, opacityValue) => (theme) => {
    const raw = (0, exports.getTransparentColor)(theme, color);
    return (0, tinycolor2_1.default)(raw).setAlpha(opacityValue).toRgbString();
};
exports.transparentize = transparentize;
const getTransparentColor = (theme, color, fallback) => {
    const hex = (0, lodash_get_1.default)(theme, `colors.${color}`, color);
    const isValid = (0, tinycolor2_1.default)(hex).isValid();
    return isValid ? hex : fallback;
};
exports.getTransparentColor = getTransparentColor;
const getColor = (rawValue, scale, theme) => {
    const alphaMatched = typeof rawValue === 'string' ? rawValue === null || rawValue === void 0 ? void 0 : rawValue.match(/:alpha\.\d\d?\d?/) : false;
    if (alphaMatched) {
        const colorMatched = rawValue === null || rawValue === void 0 ? void 0 : rawValue.match(/^.*?(?=:alpha)/);
        const color = colorMatched ? colorMatched[0] : colorMatched;
        const alphaValue = alphaMatched[0].split('.')[1];
        const alphaFromToken = (0, lodash_get_1.default)(theme.opacity, alphaValue, alphaValue);
        const alpha = alphaFromToken ? parseFloat(alphaFromToken) : 1;
        const newColor = (0, exports.transparentize)(color, alpha)(theme);
        return newColor;
    }
    else {
        return (0, lodash_get_1.default)(scale, rawValue, rawValue);
    }
};
exports.getColor = getColor;
function addDollarSignsToProps(obj, config) {
    var _a;
    const newObj = {};
    if (!(Object.keys(obj).length > 0)) {
        return;
    }
    for (const key in obj) {
        let propertyName = key;
        const propValue = obj[key];
        if ((_a = config === null || config === void 0 ? void 0 : config.aliases) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(key)) {
            propertyName = config === null || config === void 0 ? void 0 : config.aliases[key];
        }
        if (Array.isArray(propValue)) {
            //TODO: fix this ts-ignore
            const newPropValue = [];
            propValue.forEach((value) => {
                newPropValue.push(addDollarSign(propertyName, value, config));
            });
            //TODO: fix this ts-ignore
            newObj[key] = newPropValue;
        }
        else if (typeof propValue === 'object' && key.startsWith('_')) {
            newObj[key] = addDollarSignsToProps(obj[key], config);
        }
        else if (typeof propValue === 'object') {
            const newPropValue = {};
            if (propValue) {
                Object.keys(propValue).forEach((keyProp) => {
                    //TODO: fix this ts-ignore
                    newPropValue[keyProp] = addDollarSign(propertyName, propValue[keyProp], config);
                });
                newObj[key] = newPropValue;
            }
        }
        else {
            newObj[key] = addDollarSign(propertyName, propValue, config);
        }
    }
    return newObj;
}
exports.addDollarSignsToProps = addDollarSignsToProps;
const deepMerge = (target = {}, source) => {
    for (const key in source) {
        if (source.hasOwnProperty(key)) {
            if (typeof target[key] === 'object' && typeof source[key] === 'object') {
                (0, exports.deepMerge)(target[key], source[key]);
            }
            else {
                target[key] = source[key];
            }
        }
    }
    return target;
};
exports.deepMerge = deepMerge;
function checkIfPropIsStyle(key, theme) {
    // console.log(
    //   'CSSPropertiesMap key',
    //   key,
    //   CSSPropertiesMap.hasOwnProperty(key)
    // );
    // console.log(
    //   'propertyTokenMap key',
    //   key,
    //   propertyTokenMap.hasOwnProperty(key)
    // );
    // console.log('theme.aliases key', key, theme.aliases.hasOwnProperty(key));
    // console.log('config', theme);
    if (exports.CSSPropertiesMap.hasOwnProperty(key) ||
        exports.propertyTokenMap.hasOwnProperty(key) ||
        theme.aliases.hasOwnProperty(key))
        return true;
    return false;
}
const transformTheme = (componentTheme, config) => {
    const { baseStyle, variants, sizes, defaultProps } = componentTheme, rest = __rest(componentTheme, ["baseStyle", "variants", "sizes", "defaultProps"]);
    let sxProps = addDollarSignsToProps(rest, config === null || config === void 0 ? void 0 : config.theme);
    const transformedTheme = Object.assign({ variants: {
            variant: {},
            size: {},
        }, defaultProps: {} }, sxProps);
    if (baseStyle) {
        const propsWithDollarSigns = addDollarSignsToProps(baseStyle, config === null || config === void 0 ? void 0 : config.theme);
        sxProps = convertToSXForStateColorModeMediaQuery(propsWithDollarSigns, config);
    }
    // const baseStylePropsWithDollarSigns = addDollarSignsToProps(
    //   propsWithDollarSigns,
    //   config
    // );
    // Transforms NativeBase Properties to Gluestack
    // transformedTheme = { ...transformedTheme, ...sxProps };
    // Mapping variants
    if (componentTheme.variants) {
        Object.keys(variants).forEach((variant) => {
            const propsWithDollarSigns = addDollarSignsToProps(variants[variant], config === null || config === void 0 ? void 0 : config.theme);
            const sxPropsNew = convertToSXForStateColorModeMediaQuery(propsWithDollarSigns, config === null || config === void 0 ? void 0 : config.theme);
            transformedTheme.variants.variant[variant] = sxPropsNew;
        });
    }
    // Mapping Sizes
    if (componentTheme.sizes) {
        Object.keys(sizes).forEach((size) => {
            const propsWithDollarSigns = addDollarSignsToProps(sizes[size], config === null || config === void 0 ? void 0 : config.theme);
            const sxPropsNew = convertToSXForStateColorModeMediaQuery(propsWithDollarSigns, config === null || config === void 0 ? void 0 : config.theme);
            transformedTheme.variants.size[size] = sxPropsNew;
        });
    }
    // Mapping Default Props
    if (componentTheme.defaultProps) {
        const propsWithDollarSigns = addDollarSignsToProps(defaultProps, config === null || config === void 0 ? void 0 : config.theme);
        const sxPropsNew = convertToSXForStateColorModeMediaQuery(propsWithDollarSigns, config === null || config === void 0 ? void 0 : config.theme);
        transformedTheme.defaultProps = sxPropsNew;
    }
    return transformedTheme;
};
exports.transformTheme = transformTheme;
// Flattens aliases that contains array of strings, like roundedTop or roundedLeft etc.
function getFlattendMultiAliasesProps(props, config) {
    const flattenedProps = {};
    Object.keys(props).forEach((key) => {
        var _a, _b, _c;
        const propValue = props[key];
        if (((_a = config === null || config === void 0 ? void 0 : config.aliases) === null || _a === void 0 ? void 0 : _a[key]) && Array.isArray((_b = config === null || config === void 0 ? void 0 : config.aliases) === null || _b === void 0 ? void 0 : _b[key])) {
            const aliases = config === null || config === void 0 ? void 0 : config.aliases[key];
            aliases.forEach((alias) => {
                flattenedProps[alias] = propValue;
            });
        }
        else if ((_c = config === null || config === void 0 ? void 0 : config.aliases) === null || _c === void 0 ? void 0 : _c[key]) {
            flattenedProps[config === null || config === void 0 ? void 0 : config.aliases[key]] = propValue;
        }
        else {
            flattenedProps[key] = props[key];
        }
    });
    return flattenedProps;
}
exports.getFlattendMultiAliasesProps = getFlattendMultiAliasesProps;
function splitObject(obj) {
    const newObj = {};
    const remainingObj = {};
    for (const key in obj) {
        const matchingKey = stackArr.find((stackKey) => key.includes(stackKey));
        if (matchingKey) {
            newObj[key] = obj[key];
        }
        else if (typeof obj[key] === 'object') {
            const [selected, remaining] = splitObject(obj[key]);
            if (Object.keys(selected).length > 0) {
                newObj[key] = Object.assign(Object.assign({}, newObj[key]), selected);
            }
            if (Object.keys(remaining).length > 0) {
                remainingObj[key] = remaining;
            }
        }
        else {
            remainingObj[key] = obj[key];
        }
    }
    return [newObj, remainingObj];
}
exports.splitObject = splitObject;
const stackArr = [
    'margin',
    'mx',
    'my',
    'mt',
    'mb',
    'mr',
    'ml',
    'border',
    'flex',
];
